#include <event2/dns.h>
#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/util.h>
#include <event2/listener.h>
#include <event2/event.h>
#include <event2/bufferevent_ssl.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/rand.h>

#include "logger.h"
#include "ssl.h"
#include "tag/tag.h"
#include "util.h"

#ifdef PUBKEY_DATA_
#  include "pubkey_data_.h"
#endif
#ifdef ROOTPEM_DATA_
#  include "rootpem_data_.h"
#endif

#include <assert.h>
#include <stdint.h>

int ssl_log_errors(enum LogLevel level, const char *name)
{	
	int count = 0;
	int err;
	while ((err = ERR_get_error())) {		
		const char *msg = (const char*)ERR_reason_error_string(err);
		const char *lib = (const char*)ERR_lib_error_string(err);
		const char *func = (const char*)ERR_func_error_string(err);
		LogLog(level, name, "%s in %s %s\n", msg, lib, func);
		count++;
	}
	return count;
}

int ssl_init(struct telex_conf *conf)
{
	if (conf->ssl_ctx) {
		LogTrace("ssl", "already init'ed");
		return 0; // already init'ed
	}
	LogTrace("ssl", "ssl_init");

	SSL_library_init();
	ERR_load_crypto_strings();
	SSL_load_error_strings();
	OpenSSL_add_all_algorithms();	
	if (RAND_poll() == 0) {
		ssl_log_errors(LOG_FATAL, "ssl");
		LogFatal("ssl", "RAND_poll() failed; shutting down");
		return -1;
	}
	
	conf->ssl_ctx = SSL_CTX_new(TLSv1_client_method());		
	if (!conf->ssl_ctx) {
		ssl_log_errors(LOG_FATAL, "ssl");
		LogError("ssl", "Could not initialize context");
		return -1;
	}

    // Load the CAs we trust
    if (!SSL_CTX_load_verify_locations(conf->ssl_ctx, conf->ca_list, 0)) {
		ssl_log_errors(LOG_FATAL, "ssl");
		LogFatal("ssl", "Could not read CA list file %s", conf->ca_list);
		return -1;
	}

	SSL_CTX_set_verify_depth(conf->ssl_ctx,3);
    
    // TODO: make callback for cert failure
    SSL_CTX_set_verify(conf->ssl_ctx, SSL_VERIFY_PEER, NULL);

	// Tag
	tag_init();
#ifdef PUBKEY_DATA_
	if (conf->keyfile) {
	  tag_load_pubkey(conf->keyfile);
	} else {
	  tag_load_pubkey_bytes(pubkey_data_, sizeof(pubkey_data_)-1);
	}
#else
	tag_load_pubkey(conf->keyfile);
#endif

    return 0;
}

void ssl_done(struct telex_conf *conf)
{
	if (conf->ssl_ctx) {
		SSL_CTX_free(conf->ssl_ctx);
	}
}

// Inputs a 16-byte telex_secret (generated by gen_tag's key output)
// and produces a 1023-bit bignum to be used as the client's dh_priv_key
// Uses Krawczyk's crypto-correct PRG: http://eprint.iacr.org/2010/264
// page 11, PRK = state_secret, CTXinfo = uniq
BIGNUM *telex_ssl_get_dh_key(Secret state_secret, BIGNUM *res)
{
    unsigned int i;
    char *uniq = "Telex PRG";
    unsigned char buf[128];
    unsigned char out[SHA256_DIGEST_LENGTH];
    unsigned char in[128]; // > SHA256_DIGEST_LENTH + strlen(uniq) + sizeof(int)
    unsigned int out_len, in_len;
    
    // buf will end up with
    // x_{1...4}
    // x_(i+1) = HMAC{state_secret}(x_i | uniq | i)
    // uniq = "Telex PRG"
    // x_0 = empty string 
 
    memset(out, 0, sizeof(out));
    out_len = 0;    // x_0 = ""
    for (i=0; i<sizeof(buf)/SHA256_DIGEST_LENGTH; i++) {
        // Load the input for the hmac: x_i | uniq | i
        in_len = 0;
        memcpy(&in[in_len], out, out_len);          
        in_len += out_len;

        memcpy(&in[in_len], uniq, strlen(uniq));    
        in_len += strlen(uniq);

        memcpy(&in[in_len], &i, sizeof(i)); 
        in_len += sizeof(i);
 
        HMAC(EVP_sha256(), 
            state_secret, 16,
            in, in_len,
            out, &out_len);
        assert(out_len == SHA256_DIGEST_LENGTH);
        memcpy(&buf[i*SHA256_DIGEST_LENGTH], out, out_len);
    }
    
    //from bnrand, they do this for bits=1023, top=0, bottom=0.
    buf[0] |= (1<<6);
    buf[0] &= 0x7f;

    return BN_bin2bn(buf, sizeof(buf), res);
}

// Creates a new SSL connection object in state->ssl and
// initializes it for a Telex connection.
// Returns 0 on successful Telex initialization; nonzero otherwise.
int ssl_new_telex(struct telex_state *state, unsigned long server_ip)
{	
	state->ssl = SSL_new(state->conf->ssl_ctx);	
	if (!state->ssl) {
		ssl_log_errors(LOG_ERROR, state->name);
		LogError(state->name, "Could not create new telex SSL object");		
		return -1;
	}
	
    unsigned long t = htonl(time(NULL));
    char *session_id = "\x00";

    unsigned char tag_context[MAX_CONTEXT_LEN];
    memcpy(&tag_context[0], &server_ip, 4);
    memcpy(&tag_context[4], &t, 4);
    memcpy(&tag_context[8], session_id, 1);

	gen_tag(state->tag, state->secret, tag_context, MAX_CONTEXT_LEN);
	HexDump(LOG_TRACE, state->name, "tag", state->tag, sizeof(Tag));
	HexDump(LOG_TRACE, state->name, "secret", state->secret, sizeof(Secret));

    // Load the client random: 4 bytes of timestamp + 28 bytes of tag
    state->ssl->telex_client_random = malloc(32);
    memcpy(state->ssl->telex_client_random, &t, 4);
	memcpy(state->ssl->telex_client_random+4, state->tag, sizeof(Tag));

	state->ssl->telex_dh_priv_key = telex_ssl_get_dh_key(state->secret, NULL);

	return 0;
}
